<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=stylesheet href=https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css integrity=sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO crossorigin=anonymous><link href="https://fonts.googleapis.com/css?family=Open+Sans:300,400" rel=stylesheet><link rel=stylesheet type=text/css href=/css/style.css><title>HRPC</title><link rel=apple-touch-icon href=/favicons/apple-touch-icon.png><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=icon type=image/png href=/favicons/android-chrome-192x192.png sizes=192x192><link rel=icon type=image/png href=/favicons/android-chrome-512x512.png sizes=512x512><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=manifest href=/favicons/site.webmanifest><script async src="https://www.googletagmanager.com/gtag/js?id=UA-60127042-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments);}
gtag('js',new Date());gtag('config','UA-60127042-1');</script></head><body><div id=landing-content><div class=row><div class=topbannersub><nav class="navbar navbar-expand-md navbar-dark topnav"><a class=navbar-brand href=/><img src=/img/grpc-logo.png width=114 height=50></a>
<button class=navbar-toggler type=button data-toggle=collapse data-target=#navbarSupportedContent aria-controls=navbarSupportedContent aria-expanded=false aria-label="Toggle navigation">
<span class=navbar-toggler-icon></span></button><div class="topnav, collapse navbar-collapse" id=navbarSupportedContent style=float:right!important><ul class="navbar-nav ml-auto"><li class=nav-item><a class=nav-link href=/about/>About</a></li><li class="nav-item dropdown active"><a class="nav-link dropdown-toggle" href=/docs/ id=navbarDropdown role=button data-toggle=dropdown aria-haspopup=true aria-expanded=false>Docs</a><div class=dropdown-menu aria-labelledby=navbarDropdown><a class=dropdown-item href=/docs>Overview</a>
<a class=dropdown-item href=/docs/quickstart/>Quick Start</a>
<a class=dropdown-item href=/docs/guides/>Guides</a>
<a class=dropdown-item href=/docs/tutorials/>Tutorials</a>
<a class=dropdown-item href=/docs/reference/>Reference</a>
<a class=dropdown-item href=/docs/samples/>Samples</a>
<a class=dropdown-item href=/docs/talks>Presentations</a></div></li><li class=nav-item><a class=nav-link href=/blog>Blog</a></li><li class=nav-item><a class=nav-link href=/community>Community</a></li><li class=nav-item><a class=nav-link href=https://packages.grpc.io/>Packages</a></li><li class=nav-item><a class=nav-link href=/faq/>FAQ</a></li></ul></div></nav><div class=headertext>Documentation</div></div></div></div><div class="subnav d-none d-md-block"><a href=/docs>Overview</a>
|
<a href=/docs/quickstart/>Quick Start</a>
|
<a href=/docs/guides/>Guides</a>
|
<a href=/docs/tutorials/ class=active>Tutorials</a>
|
<a href=/docs/reference/>Reference</a></div><div class=quickstartcols><div class=quickstartcol1><h8>Tutorials</h8>
<a href=/docs/tutorials/auth/oauth2-objective-c/>Auth - Objective-C</a>
<a href=/docs/tutorials/async/helloasync-cpp/ class=active>Async - C++</a>
<h8>Basic</h8>
<a href=/docs/tutorials/basic/go/>Go</a>
<a href=/docs/tutorials/basic/web/>Web</a></div><div class=quickstartcol2 style=margin-top:4%><h3 style=margin-top:0>Asynchronous Basics - C++</h3><p>This tutorial shows you how to write a simple server and client in C++ using
HRPC's asynchronous/non-blocking APIs. It assumes you are already familiar with
writing simple synchronous HRPC code, as described in <a href=/docs/tutorials/basic/cpp/>HRPC Basics:
C++</a>. The example used in this tutorial follows on
from the basic <a href=https://github.com/grpc/grpc/tree/v1.25.0/examples/cpp/helloworld>Greeter example</a> we used in the
<a href=/docs/>overview</a>. You'll find it along with installation
instructions in
<a href=https://github.com/grpc/grpc/tree/v1.25.0/examples/cpp/helloworld>grpc/examples/cpp/helloworld</a>.</p><h3 id=overview>Overview</h3><p>HRPC uses the
<a href=/grpc/cpp/classgrpc_1_1_completion_queue.html><code>CompletionQueue</code></a>
API for asynchronous operations. The basic work flow
is as follows:</p><ul><li>bind a <code>CompletionQueue</code> to an RPC call</li><li>do something like a read or write, present with a unique <code>void*</code> tag</li><li>call <code>CompletionQueue::Next</code> to wait for operations to complete. If a tag
appears, it indicates that the corresponding operation is complete.</li></ul><h3 id=async-client>Async client</h3><p>To use an asynchronous client to call a remote method, you first create a
channel and stub, just as you do in a <a href=https://github.com/grpc/grpc/blob/v1.25.0/examples/cpp/helloworld/greeter_client.cc>synchronous
client</a>. Once you have your stub, you do
the following to make an asynchronous call:</p><ul><li>Initiate the RPC and create a handle for it. Bind the RPC to a
<code>CompletionQueue</code>.</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>    CompletionQueue cq;
    std<span style=color:#f92672>:</span><span style=color:#f92672>:</span>unique_ptr<span style=color:#f92672>&lt;</span>ClientAsyncResponseReader<span style=color:#f92672>&lt;</span>HelloReply<span style=color:#f92672>&gt;</span> <span style=color:#f92672>&gt;</span> rpc(
        stub_<span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span>AsyncSayHello(<span style=color:#f92672>&amp;</span>context, request, <span style=color:#f92672>&amp;</span>cq));
</code></pre></div><ul><li>Ask for the reply and final status, with a unique tag</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>    Status status;
    rpc<span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span>Finish(<span style=color:#f92672>&amp;</span>reply, <span style=color:#f92672>&amp;</span>status, (<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>)<span style=color:#ae81ff>1</span>);
</code></pre></div><ul><li>Wait for the completion queue to return the next tag. The reply and status are
ready once the tag passed into the corresponding <code>Finish()</code> call is returned.</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>    <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> got_tag;
    <span style=color:#66d9ef>bool</span> ok <span style=color:#f92672>=</span> false;
    cq.Next(<span style=color:#f92672>&amp;</span>got_tag, <span style=color:#f92672>&amp;</span>ok);
    <span style=color:#66d9ef>if</span> (ok <span style=color:#f92672>&amp;</span><span style=color:#f92672>&amp;</span> got_tag <span style=color:#f92672>=</span><span style=color:#f92672>=</span> (<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>)<span style=color:#ae81ff>1</span>) {
      <span style=color:#75715e>// check reply and status
</span><span style=color:#75715e></span>    }
</code></pre></div><p>You can see the complete client example in
<a href=https://github.com/grpc/grpc/blob/v1.25.0/examples/cpp/helloworld/greeter_async_client.cc>greeter_async_client.cc</a>.</p><h3 id=async-server>Async server</h3><p>The server implementation requests an RPC call with a tag and then waits for the
completion queue to return the tag. The basic flow for handling an RPC
asynchronously is:</p><ul><li>Build a server exporting the async service</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>    helloworld<span style=color:#f92672>:</span><span style=color:#f92672>:</span>Greeter<span style=color:#f92672>:</span><span style=color:#f92672>:</span>AsyncService service;
    ServerBuilder builder;
    builder.AddListeningPort(<span style=color:#e6db74></span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>0.0.0.0:50051</span><span style=color:#e6db74>&#34;</span>, InsecureServerCredentials());
    builder.RegisterAsyncService(<span style=color:#f92672>&amp;</span>service);
    <span style=color:#66d9ef>auto</span> cq <span style=color:#f92672>=</span> builder.AddCompletionQueue();
    <span style=color:#66d9ef>auto</span> server <span style=color:#f92672>=</span> builder.BuildAndStart();
</code></pre></div><ul><li>Request one RPC, providing a unique tag</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>    ServerContext context;
    HelloRequest request;
    ServerAsyncResponseWriter<span style=color:#f92672>&lt;</span>HelloReply<span style=color:#f92672>&gt;</span> responder;
    service.RequestSayHello(<span style=color:#f92672>&amp;</span>context, <span style=color:#f92672>&amp;</span>request, <span style=color:#f92672>&amp;</span>responder, <span style=color:#f92672>&amp;</span>cq, <span style=color:#f92672>&amp;</span>cq, (<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>)<span style=color:#ae81ff>1</span>);
</code></pre></div><ul><li>Wait for the completion queue to return the tag. The context, request and
responder are ready once the tag is retrieved.</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>    HelloReply reply;
    Status status;
    <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> got_tag;
    <span style=color:#66d9ef>bool</span> ok <span style=color:#f92672>=</span> false;
    cq.Next(<span style=color:#f92672>&amp;</span>got_tag, <span style=color:#f92672>&amp;</span>ok);
    <span style=color:#66d9ef>if</span> (ok <span style=color:#f92672>&amp;</span><span style=color:#f92672>&amp;</span> got_tag <span style=color:#f92672>=</span><span style=color:#f92672>=</span> (<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>)<span style=color:#ae81ff>1</span>) {
      <span style=color:#75715e>// set reply and status
</span><span style=color:#75715e></span>      responder.Finish(reply, status, (<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>)<span style=color:#ae81ff>2</span>);
    }
</code></pre></div><ul><li>Wait for the completion queue to return the tag. The RPC is finished when the
tag is back.</li></ul><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>    <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> got_tag;
    <span style=color:#66d9ef>bool</span> ok <span style=color:#f92672>=</span> false;
    cq.Next(<span style=color:#f92672>&amp;</span>got_tag, <span style=color:#f92672>&amp;</span>ok);
    <span style=color:#66d9ef>if</span> (ok <span style=color:#f92672>&amp;</span><span style=color:#f92672>&amp;</span> got_tag <span style=color:#f92672>=</span><span style=color:#f92672>=</span> (<span style=color:#66d9ef>void</span><span style=color:#f92672>*</span>)<span style=color:#ae81ff>2</span>) {
      <span style=color:#75715e>// clean up
</span><span style=color:#75715e></span>    }
</code></pre></div><p>This basic flow, however, doesn't take into account the server handling multiple
requests concurrently. To deal with this, our complete async server example uses
a <code>CallData</code> object to maintain the state of each RPC, and uses the address of
this object as the unique tag for the call.</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>  class CallData {
   public:
    <span style=color:#75715e>// Take in the &#34;service&#34; instance (in this case representing an asynchronous
</span><span style=color:#75715e></span>    <span style=color:#75715e>// server) and the completion queue &#34;cq&#34; used for asynchronous communication
</span><span style=color:#75715e></span>    <span style=color:#75715e>// with the HRPC runtime.
</span><span style=color:#75715e></span>    CallData(Greeter<span style=color:#f92672>:</span><span style=color:#f92672>:</span>AsyncService<span style=color:#f92672>*</span> service, ServerCompletionQueue<span style=color:#f92672>*</span> cq)
        <span style=color:#f92672>:</span> service_(service), cq_(cq), responder_(<span style=color:#f92672>&amp;</span>ctx_), status_(CREATE) {
      <span style=color:#75715e>// Invoke the serving logic right away.
</span><span style=color:#75715e></span>      Proceed();
    }

    <span style=color:#66d9ef>void</span> Proceed() {
      <span style=color:#66d9ef>if</span> (status_ <span style=color:#f92672>=</span><span style=color:#f92672>=</span> CREATE) {
        <span style=color:#75715e>// As part of the initial CREATE state, we *request* that the system
</span><span style=color:#75715e></span>        <span style=color:#75715e>// start processing SayHello requests. In this request, &#34;this&#34; acts are
</span><span style=color:#75715e></span>        <span style=color:#75715e>// the tag uniquely identifying the request (so that different CallData
</span><span style=color:#75715e></span>        <span style=color:#75715e>// instances can serve different requests concurrently), in this case
</span><span style=color:#75715e></span>        <span style=color:#75715e>// the memory address of this CallData instance.
</span><span style=color:#75715e></span>        service_<span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span>RequestSayHello(<span style=color:#f92672>&amp;</span>ctx_, <span style=color:#f92672>&amp;</span>request_, <span style=color:#f92672>&amp;</span>responder_, cq_, cq_,
                                  this);
        <span style=color:#75715e>// Make this instance progress to the PROCESS state.
</span><span style=color:#75715e></span>        status_ <span style=color:#f92672>=</span> PROCESS;
      } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (status_ <span style=color:#f92672>=</span><span style=color:#f92672>=</span> PROCESS) {
        <span style=color:#75715e>// Spawn a new CallData instance to serve new clients while we process
</span><span style=color:#75715e></span>        <span style=color:#75715e>// the one for this CallData. The instance will deallocate itself as
</span><span style=color:#75715e></span>        <span style=color:#75715e>// part of its FINISH state.
</span><span style=color:#75715e></span>        new CallData(service_, cq_);

        <span style=color:#75715e>// The actual processing.
</span><span style=color:#75715e></span>        std<span style=color:#f92672>:</span><span style=color:#f92672>:</span>string prefix(<span style=color:#e6db74></span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>Hello </span><span style=color:#e6db74>&#34;</span>);
        reply_.set_message(prefix <span style=color:#f92672>+</span> request_.name());

        <span style=color:#75715e>// And we are done! Let the HRPC runtime know we&#39;ve finished, using the
</span><span style=color:#75715e></span>        <span style=color:#75715e>// memory address of this instance as the uniquely identifying tag for
</span><span style=color:#75715e></span>        <span style=color:#75715e>// the event.
</span><span style=color:#75715e></span>        responder_.Finish(reply_, Status<span style=color:#f92672>:</span><span style=color:#f92672>:</span>OK, this);
        status_ <span style=color:#f92672>=</span> FINISH;
      } <span style=color:#66d9ef>else</span> {
        GPR_ASSERT(status_ <span style=color:#f92672>=</span><span style=color:#f92672>=</span> FINISH);
        <span style=color:#75715e>// Once in the FINISH state, deallocate ourselves (CallData).
</span><span style=color:#75715e></span>        delete this;
      }
    }
  }
</code></pre></div><p>For simplicity the server only uses one completion queue for all events, and
runs a main loop in <code>HandleRpcs</code> to query the queue:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>HandleRpcs</span>() {
    <span style=color:#75715e>// Spawn a new CallData instance to serve new clients.
</span><span style=color:#75715e></span>    new CallData(<span style=color:#f92672>&amp;</span>service_, cq_.get());
    <span style=color:#66d9ef>void</span><span style=color:#f92672>*</span> tag;  <span style=color:#75715e>// uniquely identifies a request.
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>bool</span> ok;
    <span style=color:#66d9ef>while</span> (true) {
      <span style=color:#75715e>// Block waiting to read the next event from the completion queue. The
</span><span style=color:#75715e></span>      <span style=color:#75715e>// event is uniquely identified by its tag, which in this case is the
</span><span style=color:#75715e></span>      <span style=color:#75715e>// memory address of a CallData instance.
</span><span style=color:#75715e></span>      cq_<span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span>Next(<span style=color:#f92672>&amp;</span>tag, <span style=color:#f92672>&amp;</span>ok);
      GPR_ASSERT(ok);
      static_cast<span style=color:#f92672>&lt;</span>CallData<span style=color:#f92672>*</span><span style=color:#f92672>&gt;</span>(tag)<span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span>Proceed();
    }
  }
</code></pre></div><h4 id=shutting-down-the-server>Shutting Down the Server</h4><p>We've been using a completion queue to get the async notifications. Care must be
taken to shut it down <em>after</em> the server has also been shut down.</p><p>Remember we got our completion queue instance <code>cq_</code> in <code>ServerImpl::Run()</code> by
running <code>cq_ = builder.AddCompletionQueue()</code>. Looking at
<code>ServerBuilder::AddCompletionQueue</code>'s documentation we see that</p><blockquote><p>&mldr; Caller is required to shutdown the server prior to shutting down the
returned completion queue.</p></blockquote><p>Refer to <code>ServerBuilder::AddCompletionQueue</code>'s full docstring for more details.
What this means in our example is that <code>ServerImpl's</code> destructor looks like:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>  <span style=color:#f92672>~</span>ServerImpl() {
    server_<span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span>Shutdown();
    <span style=color:#75715e>// Always shutdown the completion queue after the server.
</span><span style=color:#75715e></span>    cq_<span style=color:#f92672>-</span><span style=color:#f92672>&gt;</span>Shutdown();
  }
</code></pre></div><p>You can see our complete server example in
<a href=https://github.com/grpc/grpc/blob/v1.25.0/examples/cpp/helloworld/greeter_async_server.cc>greeter_async_server.cc</a>.</p></div></div></div><script src=https://code.jquery.com/jquery-3.3.1.slim.min.js integrity=sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo crossorigin=anonymous></script><script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script><script src=https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script></body></html>